# 垃圾回收
## 垃圾判定算法
* 计数,新增引用,计数++,减少引用--.回收计数为0的引用.
	* 问题:无法处理循环引用.
* 标记算法,可达性分析 .从必定存在引用的根节点向下标记可达的节点,回收未标记的.
	* 根节点:
		* 方法区持有的节点
		* 栈持有节点.
		* 本地方法栈只有(jni持有的java引用)
* 三色标记: 实现并发,减少程序暂停时间.
	* 白:未处理
	* 灰:正在处理(以标记,但field没全部标记)
	* 黑: 已处理/根对象
	* 流程:初始白色,找可达点标记为灰色,重复操作;找到路线最终点,标记为黑色;原路返回,把灰色标记为白色.
* Java虚拟机一般使用标记算法.标记算法可分为两种:
	* 标记-复制(coping): 整块内存等分为两块,每次标记后,复制存活到另一块内存.
	* 标记-清理(tracing): 直接用整块内存,标记后,删除非存活对象.
	* 标记-整理(compacting): 在标记-清理的基础上,移动存活对象到头部(解决内存碎片化问题).
	
## 垃圾分代概念
	* yong :分为三个区(默认8:1:1)eden,suivor(from),suivor(to)
		* eden是创世区,所有对象在此区创建.from,to两个区交替存存活的对象.
		* 使用标记-复制算法,将eden和有存活对象的幸存者区中标记的对象复制到另一个存活区,空间不足/经历gc次数>15的移动的老年区.
		*  811的设计,是为了在只使用复制算法的前提下,尽量利用空间, 复制算法,需要两块区域来回交替复制,这样实际可存储空间为1/2,使用811,
		8区用于产生对象,两个1区来回复制,浪费的空间只有1/10,当然改设计只适用于yong这种每次要大量收回对象的区域,若每次回收后存活对象都大于1区,会导致
		提前进入old区,性能下降,这时就需要调整虚拟机的分区比例,避免这种情况.
	* old:该区特征每次回收的少,存活的多.采用标记-移动算法.
	* perm(永久代),不可回收的地方(也存在回收,但要求极高).
	* metasapce:元数据,java8出现,取代之前的永久代.
## 回收动作
	* minor gc(young gc)年轻代gc,频繁触发
	* major gc(full gc)老年代gc,伴随至少一次minor gc.
## 垃圾回收器,共八种,后两种单独使用
### Serial GC(串行),年轻代使用
> 暂停程序(STW),使用一个线程处理回收.适用于单核,延时不敏感的应用 mark-coping 算法
### ParNew GC,年轻代使用
> 基于Serial,加入多线程机制.coping算法
### Parallel Scavenge Gc(并行)吞吐量收集器,年轻代使用
>  加入停顿时间控制参数,以保证单位时间的吞吐量 coping算法
### Serial Old 老年代
> 标记整理算法,单线程
### Parallel Old（ParallelMSC)老年代
> 标记整理算法.吞吐量优先.多线程.
### CMS(Concurrent Mark Sweep)用于老年代[资料](https://juejin.im/post/5c152fefe51d45366873544a)
* 优势: 并发收集、低停顿.解决 Serial 停顿问题.基于标记清除算法.
* 缺陷: 与用户线程并发,降低吞吐量;无法处理浮动垃圾;内存碎片化.
* CMS默认线程数(cpu数量+3)/4,即并发时占用了25%的cpu.
* 默认内存使用92%出发老年代回收.目的时预留部分空间给和Gc并行的用户线程.
* full gc时才会进行碎片处理.
* 流程(STW表示当前步骤需要暂停程序)
	1. Initial Mark(STW)初始标记,标记GC ROOT的直接下级.
	2. Concurrent Mark,并发标记: 可达性分析标记可达点
	3. Remark(STW).标记并发标记过程产生的新垃圾.
	4. 清除垃圾.标记清理

### G1(Garbage-First):第一时间处理垃圾最多的区块,横跨young,old
* 核心区别,设置了更小的操作单元regions,增加了gc回收时长的预测控制.
* yong/old区由多个region组成,避免了CMS内存碎片问题.
* 新增Humongous区,专门存储大对象(>=region/2).当对象>region时.会寻找连续region存储.找不到触发gc.
* RSet,解决yong gc,没必要搜索所有根的问题.所以需要记录有哪些引用了年轻代的对象
	* point-out:老年代中的一块区域,用来记录指向新生代的引用(CMS中使用)
	* g1使用,point-in 以region为单位,记录哪些分区引用当前分区中的对象.(减少记录空间大写,无需回收的region的无用扫描)
* yong gc 流程
	1. 根扫描(静态,本地对象)
	2. 更新rset
	3. 处理rset,检测从年轻代指向老年代的对象
	4. 复制对象
	5. 处理引用队列，软弱虚引用处理
* mix gc 回收老年代和年轻代
　　1. 全局标记（ｇｃｍ）
	2. 拷贝对象
	
* 时间控制原理,根据历史统计,每次gc时选取合适数量的regions,以保证gc时间<设置的时间,不能完全保证.
* 浮动垃圾问题:并发清理和用户线程并发导致(清理时,用户线程将引用置空,当次释放无法释放这个内存.这个内存就是浮动内存)
* GCM g1中的标记流程,只使用于mixed　ｇｃ
	1. 初始标记: 将根节点标黑
	2. 并发标记: 进行三色标记,与用户线程并发, 
	3. 重新标记: 处理浮动垃圾问题
	4. 清理: 清空全是垃圾的region.
	5. 其中只有1,3需要STW(stop the world)
### ZGC(ZERO PAUSE GC).保证低于10ms的jvm停顿.无分代.
> 核心.由对象标记改为指针标记,由STW标为阻塞单个对象的读取.为实现此方案引入了颜色指针和读屏障.
解决了暂停时间随堆大小膨胀的问题.
* 继承了G1region概念,同时ZGC的region大小是动态可变的.(可以更好的处理)
* 采用标记整理算法(宏观整理,细节实际是复制),活着的对象移动到另一个Region.回收整个垃圾Region.
* 流程
	1. GC Root 遍历(STW),找出GCROOT直接关联的对象
	2. 并发标记.
	3. Relocate, 对象移动,
	4.释放Region.修正指针.
* 颜色指针: 解决了对象复制,整理阶段需要STW的问题.着色阶段,会触发读屏障,等待指针更新后返回结果.
* 颜色指针四状态
	* finalizable:表示这是一个 finalizar 对象，只有 Finalizer 可以对其进行访问
	* marked0 用于识别对象在垃圾回收周期中是否被标记存活
	* marked1 用于识别对象在垃圾回收周期中是否被标记存活，存在两个的原因是因为
	一个被标记的对象可能来自上一个回收周期并未重新映射，此类对象则只需进行映射而无需重定位。
	* remap,明该引用对象需要从地址映射表中获取新地址并转移.

## 总结
* GC作用:自动管理内存
* GC对应用的影响: STW,增加响应延时;并发回收,降低应用吞吐量.所有GC器都在尽力优化这两点.一般延时优于吞吐量.
* 分代是由于不同垃圾适用于不同的处理方式;单线程GC是原始版;多线程GC是为了充分发挥多核性能;吞吐量优先GC是为了控制单次GC的时长;CMS主要减少STW,由全程STW变为初始标记,重标记阶段的STW,不整理内存碎片,
减少了复制阶段的STW;G1使用Region.不在整块处理垃圾,控制每次GC的停顿,同时复制算法不再需要固定的幸存者区,变为更小粒度的region.(主要停顿在,初始标记,重标记,对象拷贝三块);ZGC最大的特点在于引入颜色指针和都屏障将对象拷贝阶段的STW变为对单个对象读取的阻塞.

## java参数详解
* `jmap -heap [pid]` 查看gc分区参数. 
* -XX:MinHeapFreeRatio 参数用来设置堆空间最小空闲比例，默认值是 40。当堆空间的空闲内存小于这个数值时，JVM 便会扩展堆空间。

* -XX:MaxHeapFreeRatio 参数用来设置堆空间最大空闲比例，默认值是 70。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一* 个较小的堆。
* -XX:Newratio:  设置Yong 和 Old的比例，比如值为2，则Old Generation是 Yong Generation的2倍，即Yong Generation占据内存的1/3

* -XX:Newsize : 设置Yong Generation的初始值大小

* -XX:Maxnewsize：设置Yong Generation的最大值大小

* -XX:Surviorratio : 设置Eden和一个Suivior的比例，比如值为5，即Eden是To(S2)的比例是5，（From和To是一样大的），此时Eden占据Yong Generation的5/7
